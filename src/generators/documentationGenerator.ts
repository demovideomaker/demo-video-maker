import * as fs from 'fs/promises';
import * as path from 'path';
import { Feature, Component } from '../types';

export class DocumentationGenerator {
  async generateFeatureDocumentation(feature: Feature): Promise<void> {
    const docPath = path.join(feature.path, 'FEATURE.md');
    const content = this.buildFeatureDocumentation(feature);
    await fs.writeFile(docPath, content);
  }

  private buildFeatureDocumentation(feature: Feature): string {
    const doc = [];
    
    doc.push(`# ${feature.name}`);
    doc.push('');
    
    if (feature.description) {
      doc.push(`## Description`);
      doc.push(feature.description);
      doc.push('');
    }
    
    doc.push(`## Components`);
    doc.push('');
    
    const componentsByType = this.groupComponentsByType(feature.components);
    
    for (const [type, components] of Object.entries(componentsByType)) {
      if (components.length > 0) {
        doc.push(`### ${this.capitalizeType(type)}`);
        doc.push('');
        
        for (const component of components) {
          doc.push(`#### ${component.name}`);
          doc.push(`- **Path**: ${this.getRelativePath(feature.path, component.path)}`);
          doc.push(`- **Type**: ${component.type}`);
          
          if (component.exports.length > 0) {
            doc.push(`- **Exports**: ${component.exports.join(', ')}`);
          }
          
          if (component.selectors && component.selectors.length > 0) {
            doc.push(`- **Interactive Elements**:`);
            for (const selector of component.selectors) {
              doc.push(`  - ${selector.name}: \`${selector.selector}\` (${selector.action})`);
            }
          }
          
          doc.push('');
        }
      }
    }
    
    doc.push(`## Demo Automation`);
    doc.push('');
    doc.push('### Priority');
    doc.push(`This feature has a priority level of ${feature.priority}.`);
    doc.push('');
    
    doc.push('### Suggested Demo Flow');
    doc.push(this.generateSuggestedFlow(feature));
    doc.push('');
    
    doc.push('### Key Interactions');
    const interactions = this.extractKeyInteractions(feature);
    if (interactions.length > 0) {
      for (const interaction of interactions) {
        doc.push(`- ${interaction}`);
      }
    } else {
      doc.push('- No interactive elements detected');
    }
    doc.push('');
    
    doc.push('---');
    doc.push(`*Generated by Demo Video Automation Tool at ${new Date().toISOString()}*`);
    
    return doc.join('\n');
  }

  private groupComponentsByType(components: Component[]): Record<string, Component[]> {
    return components.reduce((acc, component) => {
      if (!acc[component.type]) {
        acc[component.type] = [];
      }
      acc[component.type].push(component);
      return acc;
    }, {} as Record<string, Component[]>);
  }

  private capitalizeType(type: string): string {
    return type.charAt(0).toUpperCase() + type.slice(1) + 's';
  }

  private getRelativePath(basePath: string, targetPath: string): string {
    return path.relative(basePath, targetPath);
  }

  private generateSuggestedFlow(feature: Feature): string {
    const flow = [];
    
    const pages = feature.components.filter(c => c.type === 'page');
    const components = feature.components.filter(c => c.type === 'component');
    
    if (pages.length > 0) {
      flow.push(`1. Navigate to ${pages[0].name} page`);
      
      const pageSelectors = pages.flatMap(p => p.selectors || []);
      pageSelectors.forEach((selector, index) => {
        if (selector.action === 'click') {
          flow.push(`${index + 2}. Click on "${selector.name}" element`);
        } else if (selector.action === 'input') {
          flow.push(`${index + 2}. Enter data in "${selector.name}" field`);
        }
      });
    } else if (components.length > 0) {
      flow.push(`1. Render ${components[0].name} component`);
      
      const componentSelectors = components.flatMap(c => c.selectors || []);
      componentSelectors.forEach((selector, index) => {
        if (selector.action === 'click') {
          flow.push(`${index + 2}. Interact with "${selector.name}"`);
        }
      });
    } else {
      flow.push('1. No specific flow detected - manual configuration required');
    }
    
    return flow.join('\n');
  }

  private extractKeyInteractions(feature: Feature): string[] {
    const interactions: string[] = [];
    
    for (const component of feature.components) {
      if (component.selectors) {
        for (const selector of component.selectors) {
          interactions.push(
            `${component.name}: ${selector.action} on ${selector.selector}`
          );
        }
      }
    }
    
    return interactions;
  }

  async generateProjectOverview(features: Feature[], outputPath: string): Promise<void> {
    const content = this.buildProjectOverview(features);
    await fs.writeFile(path.join(outputPath, 'DEMO_OVERVIEW.md'), content);
  }

  private buildProjectOverview(features: Feature[]): string {
    const doc = [];
    
    doc.push('# Demo Video Automation Overview');
    doc.push('');
    doc.push('## Discovered Features');
    doc.push('');
    
    const sortedFeatures = [...features].sort((a, b) => b.priority - a.priority);
    
    for (const feature of sortedFeatures) {
      doc.push(`### ${feature.name} (Priority: ${feature.priority})`);
      doc.push(`- **Path**: ${feature.path}`);
      doc.push(`- **Components**: ${feature.components.length}`);
      
      const interactions = feature.components.reduce(
        (sum, c) => sum + (c.selectors?.length || 0), 0
      );
      doc.push(`- **Interactive Elements**: ${interactions}`);
      doc.push('');
    }
    
    doc.push('## Recommended Demo Order');
    doc.push('');
    
    sortedFeatures.forEach((feature, index) => {
      doc.push(`${index + 1}. ${feature.name}`);
    });
    
    doc.push('');
    doc.push('---');
    doc.push(`*Generated at ${new Date().toISOString()}*`);
    
    return doc.join('\n');
  }
}